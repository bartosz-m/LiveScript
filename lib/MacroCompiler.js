// Generated by LiveScript 1.5.0
var util, fs, Macro, Ast, runtimePatch, check, ASTCompiler, TypeSelector, AndSelector, SeriesSelector, nodeSelector, x$, macroExpansionSelector, y$, z$, z1$, z2$, z3$, macroDefinitionSelector, z4$, z5$, z6$, z7$, z8$, MacroCompiler, this$ = this;
util = require('util');
fs = require('fs');
Macro = require('./Macro');
Ast = require('./ast');
runtimePatch = require('./runtime-patch');
check = require('./check');
ASTCompiler = require('./ASTCompiler');
TypeSelector = require('./TypeSelector');
AndSelector = require('./AndSelector');
SeriesSelector = require('./SeriesSelector');
TypeSelector = require('./TypeSelector');
nodeSelector = require('./selectors').nodeSelector;
x$ = macroExpansionSelector = new AndSelector;
x$.append(new TypeSelector('Chain'));
y$ = x$.append(new SeriesSelector);
y$.captures.start = function(it){
  return {
    line: it.first_line,
    column: it.first_column
  };
};
z$ = y$.append(new TypeSelector('Var'));
z$.captures.name = function(it){
  return it.value;
};
y$.append(new TypeSelector('Call'));
z1$ = y$.append(new TypeSelector('Call'));
z2$ = z1$.captures;
z2$.args = function(it){
  var i$, x$, ref$, len$, results$ = [];
  for (i$ = 0, len$ = (ref$ = it.args).length; i$ < len$; ++i$) {
    x$ = ref$[i$];
    results$.push(x$.value);
  }
  return results$;
};
z2$.end = function(it){
  return {
    line: it.last_line,
    column: it.last_column
  };
};
z3$ = macroDefinitionSelector = new AndSelector;
z3$.append(new TypeSelector('Assign'));
z4$ = z3$.append(new SeriesSelector);
z5$ = z4$.append(new AndSelector);
z5$.append(new TypeSelector('Chain'));
z6$ = z5$.append(new SeriesSelector);
z7$ = z6$.append(new TypeSelector('Var'));
z7$.captures.name = function(it){
  return it.value;
};
z6$.append(new TypeSelector('Call'));
z8$ = z4$.append(new TypeSelector('Fun'));
z8$.captures.ast = function(it){
  return it;
};
macroDefinitionSelector = nodeSelector({
  type: 'Assign',
  series: [
    {
      type: 'Chain',
      series: [
        {
          type: 'Var',
          capture: {
            name: function(it){
              return it.value;
            }
          }
        }, {
          type: 'Call'
        }
      ]
    }, {
      type: 'Fun',
      capture: {
        ast: function(it){
          return it;
        }
      }
    }
  ]
});
macroExpansionSelector = nodeSelector({
  type: 'Chain',
  series: [
    {
      type: 'Var',
      capture: {
        name: function(it){
          return it.value;
        },
        start: function(it){
          return {
            line: it.first_line,
            column: it.first_column
          };
        }
      }
    }, {
      type: 'Call'
    }, {
      type: 'Call',
      capture: {
        args: function(it){
          var i$, x$, ref$, len$, results$ = [];
          for (i$ = 0, len$ = (ref$ = it.args).length; i$ < len$; ++i$) {
            x$ = ref$[i$];
            results$.push(x$.value);
          }
          return results$;
        },
        end: function(it){
          return {
            line: it.last_line,
            column: it.last_column
          };
        }
      }
    }
  ]
});
MacroCompiler = (function(){
  MacroCompiler.displayName = 'MacroCompiler';
  var prototype = MacroCompiler.prototype, constructor = MacroCompiler;
  module.exports = MacroCompiler;
  function MacroCompiler(){
    this.macros = {};
    this._need_replacing = [];
  }
  MacroCompiler.prototype.compileCode = function(code, arg$){
    var filename, map, ref$, ast, fileNameJs, fileNameMap, output;
    filename = arg$.filename, map = (ref$ = arg$.map) != null ? ref$ : true;
    ast = ASTCompiler.compile(code);
    this.searchForMacros(ast);
    this.removeMacrosDefinitions(ast);
    ast = this.transformAst(ast);
    fileNameJs = filename.replace(/.ls$/, '.js');
    fileNameMap = fileNameJs + '.map';
    output = ast.compileRoot({
      filename: filename
    });
    output.setFile(filename);
    if (map) {
      return output.toStringWithSourceMap();
    } else {
      return output.toString();
    }
  };
  MacroCompiler.prototype.checkIfMacroDefinition = function(ast, parent){
    var maybeMacro, x$;
    check.isDefined(ast, 'ast');
    maybeMacro = macroDefinitionSelector.match(ast);
    if (maybeMacro) {
      x$ = new Macro(maybeMacro.name, maybeMacro.ast, parent);
      this.macros[maybeMacro.name] = x$;
      x$.originalNode = ast;
    }
  };
  MacroCompiler.prototype.checkIfMacroExpansion = function(ast, parent){
    var maybeMacro, children;
    check.isDefined(ast, 'ast');
    maybeMacro = macroExpansionSelector.match(ast);
    if (maybeMacro) {
      if (!this.macros[maybeMacro.name]) {
        return;
      }
      children = parent.children[0] === 'lines'
        ? parent.lines
        : parent.children;
      this._need_replacing.push({
        loc: {
          start: maybeMacro.start,
          end: maybeMacro.end
        },
        node: parent,
        child: ast,
        children: children,
        childIdx: children.indexOf(ast),
        macro: this.macros[maybeMacro.name],
        args: maybeMacro.args,
        isBlock: parent.children[0] === 'lines'
      });
    }
  };
  MacroCompiler.prototype.searchForMacros = function(ast){
    return ast.traverseChildren(bind$(this, 'checkIfMacroDefinition'));
  };
  MacroCompiler.prototype.removeMacrosDefinitions = function(ast){
    var n, ref$, macro, results$ = [];
    for (n in ref$ = this.macros) {
      macro = ref$[n];
      results$.push(macro.parent.removeChild(macro.originalNode));
    }
    return results$;
  };
  MacroCompiler.prototype._copy_location = curry$(function(src, dest){
    dest.first_line = src.first_line, dest.first_column = src.first_column, dest.last_line = src.last_line, dest.last_column = src.last_column, dest.line = src.line, dest.column = src.column;
  });
  MacroCompiler.prototype.copyLocation = function(src, dest, arg$){
    var recursive;
    recursive = arg$.recursive;
    this._copy_location(src, dest);
    if (recursive) {
      dest.traverseChildren(this._copy_location(src));
    }
  };
  MacroCompiler.prototype._setLocation = curry$(function(loc, node){
    var x$;
    x$ = node;
    x$.line = loc.start.line;
    x$.column = loc.start.column;
    x$.first_line = loc.start.line;
    x$.first_column = loc.start.column;
    x$.last_line = loc.end.line;
    x$.last_column = loc.end.column;
  });
  MacroCompiler.prototype.setLocation = function(loc, node, arg$){
    var recursive, setLocation;
    recursive = (arg$ != null
      ? arg$
      : check.isArgument('options', {})).recursive;
    setLocation = this._setLocation(loc);
    setLocation(node);
    if (recursive) {
      node.traverseChildren(setLocation);
    }
  };
  MacroCompiler.prototype.expandMacro = function(arg$){
    var node, child, childIdx, children, macro, args, loc, o, newAst;
    node = arg$.node, child = arg$.child, childIdx = arg$.childIdx, children = arg$.children, macro = arg$.macro, args = arg$.args, loc = arg$.loc;
    o = arguments[0];
    newAst = macro.toAst.apply(macro, args);
    this.setLocation(loc, newAst, {
      recursive: true
    });
    check.hasMethod('removeChild', node);
    return node.replaceChild(child, newAst);
  };
  MacroCompiler.prototype.findMacrosExpressions = function(ast){
    var result;
    ast.traverseChildren(bind$(this, 'checkIfMacroExpansion'));
    result = this._need_replacing;
    this._need_replacing = [];
    return result;
  };
  MacroCompiler.prototype.transformAst = function(ast){
    var expressions, i$, len$, expression, e, ref$;
    while ((expressions = this.findMacrosExpressions(ast)).length > 0) {
      for (i$ = 0, len$ = expressions.length; i$ < len$; ++i$) {
        expression = expressions[i$];
        try {
          this.expandMacro(expression);
        } catch (e$) {
          e = e$;
          e.message = (expression != null ? (ref$ = expression.macro) != null ? ref$.name : void 8 : void 8) != null
            ? "Expanding macro " + expression.macro.name + ": " + e.message
            : "Expanding macro: " + e.message;
          throw e;
        }
      }
    }
    return ast;
  };
  return MacroCompiler;
}());
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}