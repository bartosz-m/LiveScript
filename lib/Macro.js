// Generated by LiveScript 1.5.0
var util, ASTCompiler, AST, check, AndSelector, AnySelector, TypeSelector, PropertySelector, SeriesSelector, andSelector, propertySelector, exists, asNumber, flatWrapArray, nodeSelector, matchBlockExpr, asCompilableAst, astToSourceNode, asSourceNode, sourceNodeToJs, asJs, evaluateAst, Macro, toString$ = {}.toString, this$ = this;
util = require('util');
ASTCompiler = require('./ASTCompiler');
AST = require('./ast');
check = require('./check');
AndSelector = require('./AndSelector');
AnySelector = require('./AnySelector');
TypeSelector = require('./TypeSelector');
PropertySelector = require('./PropertySelector');
SeriesSelector = require('./SeriesSelector');
andSelector = function(selectors){
  var x$, i$, len$, s;
  x$ = new AndSelector;
  for (i$ = 0, len$ = selectors.length; i$ < len$; ++i$) {
    s = selectors[i$];
    x$.append(s);
  }
  return x$;
};
propertySelector = function(name, inner){
  var x$;
  x$ = new PropertySelector(name);
  if (typeof inner === 'Object') {
    x$.inner = inner;
  }
  return x$;
};
exists = function(it){
  return it != null;
};
asNumber = function(it){
  return +it;
};
flatWrapArray = function(it){
  if ('Array' !== toString$.call(it).slice(8, -1)) {
    return [it];
  } else {
    return it;
  }
};
nodeSelector = require('./selectors').nodeSelector;
matchBlockExpr = nodeSelector({
  type: 'Fun',
  properties: {
    params: null,
    body: {
      type: 'Block',
      capture: {
        block: function(it){
          return it;
        }
      },
      series: [{
        type: 'Chain',
        capture: {
          toDelete: function(it){
            return it;
          }
        },
        series: [
          {
            type: 'Literal',
            properties: {
              value: {
                capture: {
                  literal: function(it){
                    return it;
                  }
                }
              }
            }
          }, {
            type: 'Call',
            capture: {
              args: function(it){
                return it.args;
              }
            },
            properties: {
              args: null
            }
          }
        ]
      }]
    }
  }
});
asCompilableAst = function(it){
  var x$;
  if (!(it instanceof AST.Block)) {
    x$ = new AST.Block;
    x$.add(it);
    return x$;
  } else {
    return it;
  }
};
astToSourceNode = function(it){
  return it.compileRoot({
    bare: true
  });
};
asSourceNode = compose$(asCompilableAst, astToSourceNode);
sourceNodeToJs = function(it){
  return it.toString();
};
asJs = compose$(asSourceNode, sourceNodeToJs);
evaluateAst = function(it){
  return eval(asJs(it));
};
Macro = (function(){
  Macro.displayName = 'Macro';
  var prototype = Macro.prototype, constructor = Macro;
  module.exports = Macro;
  function Macro(name, ast, parent){
    var matchBlockAst, matcher, sourceNode;
    this.name = name;
    this.ast = ast;
    this.parent = parent;
    check.argsLength(3, arguments);
    check.isDefined(this.ast, 'ast');
    this.type = 'Macro';
    matchBlockAst = matchBlockExpr.match(this.ast);
    if (matchBlockAst) {
      matcher = evaluateAst(matchBlockAst.args[0]);
      this.matcher = nodeSelector(matcher);
      matchBlockAst.block.removeChild(matchBlockAst.toDelete);
    }
    this.block = new AST.Block;
    this.block.add(this.ast);
    sourceNode = eval(this.block.compileRoot({
      bare: true,
      header: false
    }));
    this.implementation = eval(sourceNode.toString());
  }
  Macro.prototype.eval = function(){
    return this.implementation.apply({
      nodeSelector: nodeSelector
    }, arguments);
  };
  Macro.prototype.toAst = function(){
    var code, ast;
    code = this.eval.apply(this, arguments);
    return ast = ASTCompiler.compile(code);
  };
  return Macro;
}());
function compose$() {
  var functions = arguments;
  return function() {
    var i, result;
    result = functions[0].apply(this, arguments);
    for (i = 1; i < functions.length; ++i) {
      result = functions[i](result);
    }
    return result;
  };
}