// Generated by LiveScript 1.5.0
var argsLength, hasMethod, isArray, isDefined, hasIterator, out$ = typeof exports != 'undefined' && exports || this, toString$ = {}.toString;
out$.argsLength = argsLength = curry$(function(expectedCount, args){
  if (args.length !== expectedCount) {
    throw Error("There should be exacly " + expectedCount + " arguments but got " + args.length);
  }
});
out$.hasMethod = hasMethod = curry$(function(method, object){
  var type;
  switch (type = toString$.call(object[method]).slice(8, -1)) {
  case 'Function':
    return;
  case 'Undefined':
  case 'Null':
    throw Error("[" + object.constructor.name + "] doesn't have property " + method);
  default:
    throw Error("[" + object.constructor.name + "]." + method + " should be Function but is a " + type);
  }
});
out$.isArray = isArray = function(a, label){
  var type;
  label == null && (label = "[" + toString$.call(a).slice(8, -1) + "]");
  if ('Array' !== (type = toString$.call(a).slice(8, -1))) {
    throw Error(label + " isn't Array");
  }
};
out$.isDefined = isDefined = function(value, name){
  if (value == null) {
    throw Error(name + " must be defined");
  }
};
out$.hasIterator = hasIterator = function(o, name){
  name == null && (name = o.constructor.name + "");
  if (!o[Symbol.iterator]) {
    throw Error(name + " doesn't have iterator");
  }
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}