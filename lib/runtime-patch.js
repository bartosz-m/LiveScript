// Generated by LiveScript 1.5.0
var ast, getType, classes, i$, len$, name, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
ast = require('./ast');
getType = function(it){
  var that;
  switch (false) {
  case !(that = it.type):
    return that;
  case !(that = it.constructor.displayName):
    return that;
  case !(that = it.constructor.name):
    return that;
  default:
    return it.toString();
  }
};
ast.NodePrototype = Object.getPrototypeOf(ast.Chain.prototype);
ast.NodePrototype.removeChild = function(){
  throw Error(getType(constructor) + " doesn't implement method remove-child");
};
ast.NodePrototype.replaceChild = function(){
  throw Error(getType(this) + " doesn't implement method replace-child");
};
ast.NodePrototype.toMacroValue = function(){
  console.warn("Warning: " + getType(this) + " doesn't implement method to-macro-value");
};
classes = ['Assign', 'Block', 'Call', 'Cascade', 'Chain', 'Literal', 'Var', 'Splat'];
for (i$ = 0, len$ = classes.length; i$ < len$; ++i$) {
  name = classes[i$];
  ast[name].prototype.type = name;
}
ast.Block.prototype[Symbol.iterator] = function*(){
  var i$, ref$, len$, line;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
    line = ref$[i$];
    (yield line);
  }
};
ast.Chain.prototype[Symbol.iterator] = function*(){
  var i$, x$, ref$, len$;
  (yield this.head);
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
    x$ = ref$[i$];
    (yield x$);
  }
};
ast.Assign.prototype[Symbol.iterator] = function*(){
  (yield this.left);
  (yield this.right);
};
ast.Fun.prototype[Symbol.iterator] = function*(){
  if (this.params != null) {
    (yield this.params);
  }
  (yield this.body);
};
ast.Block.prototype.removeChild = function(child){
  var idx;
  if (this.back === child) {
    delete this.back;
  }
  idx = this.lines.indexOf(child);
  if (!(idx >= 0)) {
    throw Error("Cannot remove [" + child.constructor.name + "] from [Block]");
  }
  return this.lines.splice(idx, 1);
};
ast.Block.prototype.replaceChild = function(child, newOne){
  var idx, ref$;
  if (this.back != null && this.back === child) {
    this.back = newOne;
  }
  idx = this.lines.indexOf(child);
  if (!(idx >= 0)) {
    throw Error("Cannot replace [" + child.constructor.name + "] in [Block]");
  }
  if (newOne.type === 'Block') {
    return (ref$ = this.lines).splice.apply(ref$, [idx, 1].concat(arrayFrom$(newOne.lines)));
  } else {
    return (ref$ = this.lines).splice.apply(ref$, [idx, 1].concat(arrayFrom$(newOne)));
  }
};
ast.Cascade.prototype.replaceChild = function(child, newOne){
  switch (false) {
  case this.input !== child:
    return this.input = newOne;
  case this.output !== child:
    return this.output = newOne;
  default:
    throw Error("Cannot replace [" + getType(child) + "] in [Cascade]");
  }
};
ast.Assign.prototype.replaceChild = function(child, newOne){
  if (this.right === child) {
    return this.right = newOne;
  } else if (this.left === child) {
    return this.left = newOne;
  } else {
    throw Error("Cannot replace [" + getType(child) + "] in [Assign]");
  }
};
ast.Var.prototype[Symbol.iterator] = function*(){
  return (yield this.value);
};
ast.Call.prototype[Symbol.iterator] = function*(){
  return (yield this.args);
};
ast.Splat.prototype[Symbol.iterator] = function*(){
  return (yield this.it);
};
ast.Splat.prototype.replaceChild = function(child, newOne){
  if (child === this.it) {
    return this.it = newOne;
  } else {
    throw Error("Cannot replace [" + getType(child) + "] in [Splat]");
  }
};
ast.Literal.prototype.toMacroValue = function(){
  return this.value;
};
ast.Var.prototype.toMacroValue = function(){
  return this.value;
};