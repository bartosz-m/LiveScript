// Generated by LiveScript 1.5.0
var ast, getType, classes, i$, len$, name;
ast = require('./ast');
getType = function(it){
  var that;
  switch (false) {
  case !(that = it.type):
    return that;
  case !(that = it.constructor.displayName):
    return that;
  case !(that = it.constructor.name):
    return that;
  default:
    return it.toString();
  }
};
ast.NodePrototype = Object.getPrototypeOf(ast.Chain.prototype);
ast.NodePrototype.removeChild = function(){
  throw Error(getType(constructor) + " doesn't implement method remove-child");
};
ast.NodePrototype.replaceChild = function(){
  throw Error(getType(this) + " doesn't implement method replace-child");
};
classes = ['Assign', 'Block', 'Call', 'Cascade', 'Chain', 'Var'];
for (i$ = 0, len$ = classes.length; i$ < len$; ++i$) {
  name = classes[i$];
  ast[name].prototype.type = name;
}
ast.Block.prototype[Symbol.iterator] = function*(){
  var i$, ref$, len$, line;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
    line = ref$[i$];
    (yield line);
  }
};
ast.Chain.prototype[Symbol.iterator] = function*(){
  var i$, x$, ref$, len$;
  (yield this.head);
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
    x$ = ref$[i$];
    (yield x$);
  }
};
ast.Assign.prototype[Symbol.iterator] = function*(){
  (yield this.left);
  (yield this.right);
};
ast.Fun.prototype[Symbol.iterator] = function*(){
  if (this.params != null) {
    (yield this.params);
  }
  (yield this.body);
};
ast.Block.prototype.removeChild = function(child){
  var idx;
  idx = this.lines.indexOf(child);
  if (this.back != null && this.back === child) {
    delete this.back;
    return child;
  }
  if (!(idx >= 0)) {
    throw Error("[" + child.constructor.name + "] nie jest potomkiem [Block]");
  }
  return this.lines.splice(idx, 1);
};
ast.Block.prototype.replaceChild = function(child, newOne){
  var idx;
  idx = this.lines.indexOf(child);
  if (this.back != null && this.back === child) {
    this.back = newOne;
    return child;
  }
  if (!(idx >= 0)) {
    throw Error("[" + child.constructor.name + "] nie jest potomkiem [Block]");
  }
  return this.lines.splice(idx, 1, newOne);
};
ast.Cascade.prototype.replaceChild = function(child, newOne){
  switch (false) {
  case this.input !== child:
    return this.input = newOne;
  case this.output !== child:
    return this.output = newOne;
  default:
    throw Error("[" + getType(child) + "] nie jest potomkiem [Cascade]");
  }
};
ast.Var.prototype[Symbol.iterator] = function*(){
  return (yield this.value);
};
ast.Call.prototype[Symbol.iterator] = function*(){
  return (yield this.args);
};